<!doctype HTML>
<html>
<head>
<link rel="icon" type="image/ico" href="images/concurlogoscaled.ico"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<title>Concur Spec: Type System</title>
</head>
<body>
<h1 style="font-size:36px;">
    <a href="concur.html">
    <img alt="Concur Logo" src="images/concurtextlogo.png" style="width:128px;height:48px;">
    </a>
    Type System 
</h1>
<hr />
<h2 class="logoed">
    Overview
</h2>
    Concur's type system provides for an interesting hybrid of static type-checking and dynamic typing. Exact type inference for Concur's generalized type system is undecidable if strong normalization is required, so Concur instead has a well-defined limit to what types can be inferred, and it provides two levels of type-safety, "Non-Strict", and "Strict". This approach allows the flexibility of typing in a dynamic language, while still rejecting a large subset of poorly-typed programs. Concur's type system provides subtyping, ad-hoc polymorphism, parametric types and type variables. 
<hr />
<h2 class="logoed">
    Subtyping
</h2>
    A type <var>B</var> in Concur may be related to a type <var>C</var> in Concur by the
    relations of subtyping and supertyping. 
    If <var>A</var> is a subtype of <var>B</var>, then it implies that for every function
    where <var>B</var> is demanded, <var>A</var> is accepted, as well. For example, 
    wherever a <code>Num</code> is required as an argument to a function
    , an <code>Int</code> may be passed instead. Unlike many Object-Oriented
    languages, Concur does not restrict subtyping to a strict tree [or forest]
    structure --
    instead, subtyping in Concur forms a directed graph of relations between types.
    For example: <br />
    <object width="512px" height="256px" data="graphs/exgraph.svg" type="image/svg+xml">
    </object> 
    <object width="256px" height="256px" data="graphs/diamond.svg" type="image/svg+xml">
    </object> <br /> 
    In the above diagrams, arrows lead from supertypes to subtypes. <br /> <br />
    Concur has a type called "Any" that is the subtype of no types, but is the
    supertype of all types. A function parameter typed as "Any" may be of any type.
    It is similar in function to "Object" in other languages. Every new type
    automatically subtypes Any. <br /><br />
    You may notice that in the first diagram, Int and Integer are subtypes of each
    other. Any directed cycle of types in Concur implies that all types connected
    are actually the same type, but with different names. The same goes for Bool
    and Boolean -- they both describe the same type [since all functions that
    accept Bool must also accept Boolean and vice-versa].<br />
    <h3>Rules of Subtyping</h3>
    Note: A &sub; B implies that A subtypes B, A = B implies that A and B are equal,
    A &ne; B implies inequality, and A &lt; &gt; B implies that A and B are disjoint.
    <br /> <br />
    <pre>
A &sub; B   AND   B &sub; C    &#8594;    A &sub; C


A &sub; B   AND   B &sub; A    &#8594;    A = B

Corollary: A = B    &#8594;    A &sub; B  AND  B &sub; A


A = B   AND   B = C    &#8594;    A = C

A = B    &#8594;    B = A

NOT (A = B)    &#8594;    A &ne; B

NOT (A &sub; B  OR  B &sub; A)    &#8594;    A &lt; &gt; B
</pre>
<h3>Syntax</h3>
These are all declarations that can inhabit a namespace
<h4>Declaration</h4>
<code>type <var>A</var></code> <br /> <br />
Declares that <var>A</var> is a type. All declarations of types in Concur
are tied to namespaces, and the same scoping rules for function definitions
apply for types. 
<h4>Subtyping</h4>
<code><var>A</var> subtypes <var>B</var></code> <br />
<code><var>A</var> subs <var>B</var></code> <br />
<code><var>A</var> &lt;: <var>B</var></code> <br />
<br />
For example, the earlier diamond-shaped graph could be represented as: <br />
<code>Button &lt;: Rectangle <br />
Button &lt;: Clickable </code><br />
<h4>Supertyping</h4>
<code><var>A</var> supertypes <var>B</var> </code> <br />
<code><var>A</var> sups <var>B</var> </code> <br />
<code><var>A</var> :&gt; <var>B</var> </code> <br /> <br />
Example: <br />
<code>Number :&gt; Integer </code> 
<h4>Type Equality</h4>
<code>typedef <var>A</var> <var>B</var> </code> <br /> <br />
Example: <br />
<code>typedef Int Integer</code>
<h3>Requirements</h3>
    Concur actually specifies two different levels of type-strictness.
    The first level only rejects programs that "cannot possibly be" typed
    correctly, and the second level rejects any program that cannot be
    proved to be typed correctly at compile-time. Implementations are
    required to provide both levels of strictness.
    <h4>Non-Strict Concur</h4>
    In Non-Strict mode, a typing error arises iff a function's accepted
    argument type is disjoint from the recieved argument's type. This enforces
    that programs that are "obviously typed incorrectly" are rejected by
    the type-checker -- for example, a function typed as requiring a Bool
    for its first argument cannot be passed something that is definitely
    an Int [at compile-time], or a type error will be raised [at compile-time].
    However, something requiring a Bool may accept an "Any" in non-strict mode,
    because at compile-time, it is impossible to determine whether the contents
    of the argument provided are actually a Bool or something else. At run-time
    when the argument is actually evaluated, a type-error will arise if the
    argument turns out to not be a Bool. 
    <h4>Strict Concur</h4>
    In Strict Concur, a
    compile-time type error arises wherever a function requires an argument
    of type <var>A</var>, but the provided argument <var>B</var> cannot be
    proven to be a subtype of A. The requirements of the method for
    proving subtyping are provided in a later section. Under the Strict
    variant, a function accepting an Int cannot be provided an argument typed
    as "Any". Run-time type errors are still possible in Strict Concur, but
    they have to be explicitly defined by the user [see below]. 
<h2 class="logoed">Parametric Types</h2>
    A parametric type is a type that depends on the types it is parametized with.
    An example of a parametric type would be a list of elements of some defined type, or
    <code>listof <var>A</var></code>, where <var>A</var> is the type of each
    element. Just like regular types, parametric types may be subtypes or supertypes to
    other types. For example: <br /><br />
    <code> typedef (listof Any) list </code><br /><br />
    We will use "parametric container" to refer to the container (the "t" in "t a"), and
    "parameterized type" to refer to complete parametric types ("t a"). <br /> 

    Parametric containers are syntactically similar to functions -- 
    they are always reordered to be the first item in an S-expression. They may also be
    nested as function applications would.<br />
    Parametric types can be declared using "type", but with the name of the parametric
    container coming first, followed by the domain that each parameter can take on. <br /><br />
    Examples: <br /> <br />
    <code>type Vector2D Number //Ex: Vector2D(Float) and Vector2D(Int)</code> <br />
    <code>type Dict Hashable Any </code> <br /> <br />
    It is a type error if a parametric type is instantiated with parameters outside of
    the specified domains. <br />
<h2 class="logoed">Type Variables</h2>
    <h3>In subtyping relations</h3>
    Type variables are "placeholders" for a type. A type variable may be any
    valid identifier that is not already used as a type or as a function.
    Type variables are useful for specifying universal relations between types.
    <br /><br />For example: <br />
    <br /><code>Any :&gt; A</code> <br />for every type A. <br /><br />
    In Concur, the "for every" is implied. In addition, with a type
    variable, it is possible to express general subtyping relations of parametric types.
    For example: <br /><br />
    <code>Termin A &lt;: A</code><br /><br />
    "Termin" is a parametric type that expresses "provable termination" --
    Since values in Concur are actually computations 
    [See <a href="evaluation.html">Evaluation</a>], it is possible to give
    a value a type parameterized with "Termin" to express that the computation
    can be proven to terminate. "Termin" does not claim to capture all terminating
    computations, as that would solve the halting problem -- instead, it is a
    convenience type that allows programmers to partially reason about termination,
    and it could potentially help a compiler/interpreter make smarter decisions about
    code. To understand the above declaration, try substituting "Int" for "A". <br />
    <br /><code>Termin Int &lt;: Int</code><br /><br />
    This reads as "wherever an Int is accepted, a Termin Int is accepted as well".
    However, the relation does not go the other way by design -- if a terminating
    computation that returns an Int is required, it is required, and a type error
    will be yielded if one is not provided.  
    <h4>Rules</h4>
    As of v1.0, it is illegal to provide anything other than a type variable
    to a parametric type in a subtyping relation [for the sake of simplicity] -- the subtyping
    constraint must be universal across all type parameters. <br />
    Example: <br />
    <code>Either A B :&gt; A</code><br />
    <code>Either A B :&gt; B</code><br /> <br />
    The above parametric type would express the type of 
    something that could be of either type A or of type B
    -- for example, "Either Num String" means both <code>Either Num String :&gt; Num</code> and
    <code>Either Num String :&gt; String</code>. However, these are not valid as subtyping
    relations by themselves, because they do not express relations over the whole domain of
    <code>Either A B</code>

    <h3>In function definitions</h3>
    Type variables may also appear in function definitions. For example, let's say we want to
    define the identity function in Concur. The simple way to do this would be: <br />
<pre>def identity x
    x</pre> <br />
    How would we express the type of this function? Functions in Concur from type <var>A</var>
    to type <var>B</var> are expressed by <code><var>A</var> -&gt; <var>B</var></code> .
    Since the identity function simply returns its argument, its type must be 
    <code>A -&gt; A</code>. If we want to explicitly state this in the function definition,
    we can say: <br />
<pre>def (A identity) (A x)
    x</pre> <br /> Provided that A is a valid type variable, the above will work as intended.
    Using type variables, we can express parametric polymorphism. Another example would be
    <code>map :: (A -&gt; B) -&gt; (collectionof(A) -&gt; collectionof(B))</code>, where "::"
    reads as "is typed as".
    (this is actually a function of two arguments. See currying.)
<h2 class="logoed">Ad-hoc Polymorphism</h2>
    Ad-hoc polymorphism in Concur allows a function to accept multiple different types,
    and select the function body for the correct type. This makes it possible for functions
    like "print" to be able to work over a wide range of types. For example, <br />
<pre>def print (float in) t
    //definition goes here

def print (int in) t
    //yet another definition

def print (string in) t
    //... and so on</pre><br />

    Ad-hoc polymorphism also allows for subtypes to mimic object-oriented inheritance-based
    polymorphism -- for example, let's say that we have: <br />
<pre>def draw (Enemy in) t
    //definition goes here</pre> <br />
    as a method to draw a generic enemy, and we want to specialize that for a new type that
    subtypes enemy, let's call it HugeEnemy. In order to change the behavior of draw for a
    HugeEnemy, all we have to do is: <br />
<pre>def draw (HugeEnemy in) t
    //definition goes here</pre> <br />
    And if we wanted Enemy's draw function to mimic a pure virtual method in other languages,
    all we have to do is change the first definition to: <br />
<pre>def draw (Enemy in) t
    virtual</pre> <br />
    virtual is of type "error", so an error will be raised if a subtype of Enemy tries
    to pass itself to draw, and a subtype-specific definition does not exist. 
    Note: In Concur, it is illegal to define two functions with names and
    type signatures that are exactly the same.
    <br /> <br />
    <h3>Selection</h3>
    In general, ad-hoc polymorphic functions have their applications determined in a
    left-to-right, most-specific-to-least-specific order of precedence. Left-to-right order
    is due to the fact that every function in Concur is curried -- for example, let's say that
    you have a function <code>f</code> that has two definitions, one of which is typed as
    <code>f :: Num -&gt; (Int -&gt; Bool)</code> and the other of which is typed as
    <code>f :: Int -&gt; (Num -&gt; Bool)</code> -- If we were to supply two Ints to the
    function, the second option would be selected, because it is more specific in the
    leftmost argument. A is more specific than B if A is a subtype of B. 

    <h3>The type of ad-hoc polymorphic functions</h3>
    Ad-hoc polymorphic functions take on the type:<br />
    <code>type Poly function function</code> <br />
    and the rules:<br />
    <code>Poly A B &lt;: function</code><br />
    <code>Poly A B &lt;: A</code><br />
    <code>Poly A B &lt;: B</code><br />
    These constraints allow higher-order polymorphic functions to work as intended. 
    For polymorphic
    functions with more than two ad-hoc definitions, "Poly" types nested from left-to-right
    may be used. E.G: "Poly A (Poly B (Poly C D))" where A, B, C, and D are function types.
<hr/>

<h2 class="logoed">Structural Types</h2>
    Structural types are used to specify how types are stored in memory. In general, if
    A is a type, and S is a structural type, then A is stored as the structure S represents
    in memory if A is a subtype of S. It is a type error for a type to subtype more than one
    structural type. <br />
<h2>Structural Type Primitives</h2>
    There exist only four structural type primitives in Concur, from which all other structural
    types are derived.
    <h3>Byte</h3>
        Represents a single byte (sequence of eight bits). Similar to "char" in C.
    <h3>Pair A B</h3>
        Represents storage representing type A followed by storage representing type B.
    <h3>ArrayOf N A</h3>
        Represents contiguous storage of N items of type A. Follows the definition: <br />
        <br /><code>type ArrayOf(tNum, A)</code> <br /><br />
        Where "tNum" is a supertype of integer literals implicitly lifted to the
        type level (shh, don't tell Haskell!). If N is declared as "tNum", the array may
        have any arbitrary number of elements<br />
        For example: <br />
        <code>Arrayof(tNum, Char) //Could represent a string of arbitrary length</code>
        <code>ArrayOf(100, Char) //Could represent a fixed-width string of 100 characters</code>
        <code>ArrayOf(100, ArrayOf(100, Float)) //Could represent a 2D matrix of floats.</code>
    <h3>-&gt; A B</h3>
        Functions are technically structural types.
<h2 class="logoed">Type Casting</h2>
    Structural types may be cast to become one of their subtypes. 
    The function: <code> <br />
    def (B cast) (type B) (S value) ...</code> <br/>
    Can be used to convert a value of structural type S into a value of type B, where S is the
    structural supertype of B. (The above
    function definition is pseudo-code -- "cast" is a primitive) <br />
    "Cast" is a necessary evil to declare constructors. E.G: <br /><br />
<pre>
    type Vector2D
    Vector2D subs Pair(Int, Int)
    def (Vector2D makeVector2D) (Int x) (Int y)
        cast Vector2D cons(x, y)
</pre>

<h2 class="logoed">Type Checking and Inference</h2>
    Type inference may be performed using the same mechanism as Hindley-Milner,
    with the addition of subtypes. Types are elaborated starting from the most general type
    (Any) down to the least subtype that can be proven by the type checker. Mechanism left
    as an exercise to the reader.
<hr />
<h6>
<a href="concur.html">
    <img alt="Concur Logo" src="images/concurtextlogo.png" style="width:64px;height:24px;">
    <br />
    Back to Main Page
</a>
</h6>
</body>
